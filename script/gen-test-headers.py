#!/usr/bin/env python


import argparse
import os
import re
import string
import sys


header_filenames = []


def generate_header_files(src_filenames, namespace=None, exclude=[]):
    for src_filename in src_filenames:
        if os.path.basename(src_filename) in exclude:
            continue
        src_filepath = os.path.realpath(src_filename)
        file_id = os.path.basename(src_filename).replace(".c", "")
        dest_filepath = file_id + ".h"
        if namespace:
            file_id = "%s_%s" % (namespace, file_id)
        try:
            generate_header_file(file_id, src_filepath, dest_filepath)
            header_filenames.append(dest_filepath)
        except Exception as e:
            print("failed to generate test header file:")
            print("  source: %s" % src_filepath)
            print("  dest:   %s" % dest_filepath)
            print("  error:  %s" % e)
            return 1
    return 0


def generate_header_file(file_id, src_filepath, dest_filepath):
    test_declarations = []
    test_invocations = []
    with open(src_filepath, "r") as src_file:
        for line in src_file.readlines():
            if line.find("void tests_") != 0:
                continue
            test_declarations.append(line.replace(" {", ";").strip())
            test_invocations.append(
                "\tcmocka_unit_test_setup_teardown(" +
                re.sub(r"\(.*", "", line).replace("void ", "").strip() +
                ", setup_each, teardown_each),")
    with open(dest_filepath, "w") as dest_file:
        output = (
            "/* Automatically generated by script/gen-test-headers.py */\n"
            "#ifndef _tests_{file_id}_h_\n"
            "#define _tests_{file_id}_h_ 1\n"
            "\n"
            "#define setup_each     tests_{file_id}_setup_each\n"
            "#define teardown_each  tests_{file_id}_teardown_each\n"
            "\n"
            "int tests_{file_id}_setup_each(void **state);\n"
            "int tests_{file_id}_teardown_each(void **state);\n"
            "\n"
            "{test_declarations_str}\n"
            "\n"
            "static const struct CMUnitTest tests_{file_id}[] = {lq}\n"
            "{test_invocations_str}\n"
            "{rq};\n"
            "\n"
            "#undef setup_each\n"
            "#undef teardown_each\n"
            "\n"
            "#endif")
        dest_file.write(output.format(file_id=file_id, lq="{", rq="}",
            test_declarations_str="\n".join(test_declarations),
            test_invocations_str="\n".join(test_invocations)))


def generate_main_header_file(template_filepath):
    header_includes = [
        "#include <stdarg.h>",
        "#include <stddef.h>",
        "#include <stdio.h>",
        "#include <setjmp.h>",
        "#include <stdint.h>",
        "#include <string.h>",
        "#include <stdlib.h>",
        "#include \"../../deps/cmocka/include/cmocka.h\"",
    ]

    with open(template_filepath, "r") as template_file:
        for header_filename in header_filenames:
            header_includes.append("#include \"" + header_filename + "\"")
        output = template_file.read().format(
                test_header_includes_str="\n".join(header_includes))
        with open("main.h", "w") as dest_file:
            dest_file.write(output)

    return 0


def main():
    parser = argparse.ArgumentParser(description="Generate test header files")
    parser.add_argument("-n", "--namespace",
            metavar="namespace", dest="namespace", required=True,
            help="namespace used in tests")
    parser.add_argument("-i", "--input",
            metavar="file.c", dest="input", nargs="+", required=True,
            help="provide test files (.c)")
    parser.add_argument("-m", "--main",
            metavar="main.h", dest="main", required=True,
            help="path to main.h.in")
    parser.add_argument("-x", "--exclude",
            metavar="file.c", dest="exclude", nargs="+", default=[],
            help="provide files to be ignored")
    args = parser.parse_args()
    args = vars(args)

    ret_code = generate_header_files(args["input"], exclude=args["exclude"],
            namespace=args["namespace"])
    if ret_code != 0:
        return ret_code

    ret_code = generate_main_header_file(args["main"])
    if ret_code != 0:
        return ret_code

    return 0


if __name__ == "__main__":
    sys.exit(main())
